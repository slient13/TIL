`{ Erich Gamma, Rechard Helm, Ralph Johnson, John Vissides }` 네명을 일컷는 말으로, 이 네명이 제시한 23개의 디자인 패턴이 가장 유명하다. 목적에 따라 3가지로 분류할 수 있다.

## 생성 패턴
객체의 생성과 관련된 패턴. 특정 객체가 생성되거나 변경되어도 그 영향이 최소화되도록 하는데 초점.
- abstract factory: 구체적인 구현은 생략하고 인터페이스만 규정해서 객체들을 묶고, 구체적인 구현은 상속받은 서브 클래스에서 하거나 인터페이스에 맞춰진 외부 클래스로 처리하는 방법.
- builder: 객체의 생성과 표현을 분리.
- factory method: 객체 생성을 직접 하는 대신 자신을 상속받은 서브 클래스에서 하도록 하여 생성 권한을 위임. -> 캡슐화.
- prototype: 원본 객체를 복제하여 새 객체 생성.
- singleton: 단 하나의 객체만 미리 만들어서 돌려씀.

## 구조 패턴
프로그램 내 자료 구조나 인터페이스 구조 등에 관한 패턴. 기존의 구조를 조합하거나 하여 더 큰 구조를 표현할 수 있도록 해줌.
- adapter: 클래스의 인터페이스를 다른 클래스에서도 사용 가능하도록 연결, 변환.
- bridge: 구현부와 추상층을 분리. 각자 따로 확장할 수 있도록 함. (인터페이스와 구현이 직접 연결되는 대신 중간에 연결시켜주는 일종의 다리를 만들어서 상호 분리)
- composite: 객체들의 관계를 트리 구조로 다룸으로써 복합 객체와 단일 객체를 구분 없이 다룰 수 있도록 하는 방식
- decorator: 객체에 다른 객체를 덧붙히는 방식으로 상황에 따른 유연한 객체간 조합을 제공.
- facade: 어떠한 기능을 수행하기 위해 이리저리 타고 들어가서 서브 시스템의 인터페이스를 직접 통하지 않고서도 조작할 수 있도록 통합된 인터페이스를 제공하는 기법.
- flyweight: 객체가 사용이 종료되더라도 삭제하는 대신 초기화하여 가지고 있다가 나중에 객체 생성이 요청되면 재사용해서 효율을 증대시키는 방법. 객체의 생성, 삭제가 잦은 상황에 용이함.
- proxy: 객체를 직접 참조하여 기능을 수행하는 대신 대리자를 두어 기능 요청을 전달하고 대리자가 대신 객체를 직접 참조하도록 하는 것.

## 행동 패턴
반복적으로 사용되는 객체들의 커뮤니케이션 패턴화. 상호작용하는 알고리즘 및 책임 분배 방법에 대해 정의. 결합도를 최대한 낮추는 것이 목적.
- chain of responsibility: 요청을 받아 처리하는 객체를 연쇄적으로 묶어서 앞선 객체가 성공적으로 처리하지 못하면 뒤이은 객체가 받아 처리를 시도하도록 만드는 패턴.
- command: 요청 자체를 별도의 객체로 만들어 캡슐화 하는 것. 이렇게 하면 요청 자체를 재사용할 수 있으며, 이를 통한 최적화가 가능하다.
- interpreter: 특정 언어의 문법 표현을 정의하기 위한 패턴.
- iterator: 여러개의 컬렉션에 대해 공통된 인터페이스를 제공함으로써 세부 구현사항에 관계 없이 서로 다른 컬렉션을 같은 인터페이스로 조작할 수 있도록 하는 것.
- mediator: 한 집합 내 객체들의 상호작용을 캡슐화하여 새로운 객체로 정의.
- memonto: 특정 시점의 객체의 정보를 따로 객체로 만들어 기록. 이를 통해 객체 상태에 대한 기록 및 원복을 가능하도록 함.
- observer: 객체의 상태를 계속 관찰하다가 변화가 관측되면 자동으로 관련된 요소에 그 영향을 전파하는 것. 이를 통해 여러 객체를 서로 동기화 할 수 있음.
- state: 객체 내부에 정보를 가지고 있도록 하고, 그에 따라 다른 동작을 수행하도록 하는 것. 객체가 상황에 적응할 수 있도록 해줌.
- strategy: 동일한 목적을 가진 알고리즘 여러개를 하나로 묶어 공통된 인터페이스로 조작 가능하도록 하고, 요청한 데이터의 상태에 따라 가장 효율적인 알고리즘을 선택하여 적용하도록 하는 패턴.
- template method: 상위 클래스에서는 오로지 알고리즘의 규격만을 정의하고, 세부 구현은 서브 클래스에 위임하는 것.
- visitor: 객체가 어떠한 동작을 해야 할지를 직접 알고 있도록 구현하는 대신 관련된 동작을 별도의 클래스로 분리하고 객체의 타입 및 데이터에 따라 지정한 동작을 수행하도록 하는 것. 