역링크: `$= dv.current().file.inlinks.filter((e) => e.path.substring(0, 5) !== "__TIL")`

# scope
## scope 종류
*참고* // [[#scope chain]]에 의해 순회할 때는 깊은 곳에서 얕은 곳으로, 즉 `block -> local -> closure -> ... -> scope -> global` 순서로 이루어진다.

- `global` // 최상위 스코프. 여기에 저장된 값은 전역적으로 관리되며 어디서든 접근할 수 있다. `window` 객체의 스코프가 이에 해당하며 그렇기에 `window` 객체에 포함된 함수나 값은 `window.`의 접두사를 생략할 수 있다.
- `script` // 전역 스코프. `global scope`와 유사하게 전역적으로 접근할 수 있는 스코프이지만 그것보다는 우선순위가 높다. 또한, `window` 객체보다 앞서 적용되는 것이기에 `window.$var` 형태의 접근에서는 `script scope`의 내용은 접근할 수 없다.
- `closure` // 함수 안에서 새로운 함수가 정의되는 등 스코프가 겹칠 때 발생하는 특수한 스코프이다. 이 때 상위 스코프의 역할을 한다.
- `local` // 지역 스코프. 특정 함수나 객체 내부에 한정된 스코프이다. 여기에 정의된 내용은 그 안에서 새로 정의된 함수나 객체가 아니라면 접근할 수 없다.
- `block` // 블록 스코프. `{ }`으로 감싸진 구역에 한정해 적용되는 특수한 스코프. `for문`이나 `if문`은 물론이고, 그냥 빈 공간에 괄호만 쳐서 만든 블록에서도 적용된다.

## 변수 생성시 위치
- *수식어 없이 선언한 변수* // 언제 어디서 선언하든 항시 ==global scope==에 저장됨.
- *`var` 키워드로 선언한 변수* // 최상위 스코프에서는 ==global scope==에 저장됨. 로컬 스코프에서는 해당 로컬 스코프에 저장됨.
- *`let` 키워드로 선언한 변수* // 최상위 스코프에서는 ==script scope==에 저장됨. 로컬 스코프에서는 해당 로컬 스코프에 저장됨. 
- *`const` 키워드로 선언한 변수* // 최상위 스코프에서는 ==script scope==에 저장됨. 로컬 스코프에서는 해당 로컬 스코프에 저장됨. 

## scope chain
특정 스코프에서 변수나 함수 등을 참조하려 시도했을 때 로컬 스코프에 존재하지 않는다면 더 상위의 로컬 스코프, ==script score==, ==global scope== 순서로 점점 큰 범위의 스코프를 탐색해나가며 원하는 정보를 찾는 동작 방식.

이러한 방식 덕분에 함수 내부에서도 위부 정보에 접근할 수 있으며, 같은 이름의 변수가 존재하더라도 깊은 위치에서 선언된 변수등이 먼저 선택받음을 보장할 수 있다.

*주의* [[#scope chain]]은 단지 함수 안에서 다른 함수를 호출하는 것으로는 발생하지 않는다. 함수 내부에서 또 다른 함수를 정의하는 등 [[closure]]가 존재해야만 발생한다.

## window
웹 브라우저에서 기본적으로 제공되는 최상위 스코프. `alert`등 다양한 함수와 값이 포함되어 있다. 스코프는 ==global 스코프==가 된다.

# debugger
웹 브라우저마다 제공하는 개발용 도구로, `F12` 혹은 `ctrl + shift + i`를 눌러 열 수 있다. 개발에 도움이 되는 다양한 정보들을 제공하며, 필요시 플러그인 등을 통해 기능을 확장할 수 있다.

## sources
스크립트 코드에 대한 내용을 다룰 수 있는 카테고리이다. 다른 디버거가 그러하듯 ==breakpoint==를 제공하며, 특정 시점에 각 요소들의 값 및 callstack 등을 볼 수 있게 제공한다.

# execute context
==window==나 특정 함수 등 동작과 관련된 내용을 담고 있는 요소이다. 기본적으로 로컬 스코프의 정보들을 가지고 있으며, 함수가 호출될 시 ==callstack==에 포함된다.

# 동기/비동기
==동기==란 타이밍을 맞춰 순차적으로 실행하는 방식이다. 이러한 방식은 언제나 실행의 순서가 동일하게 보장된다는 이점이 있으나, 중간에 특정 동작이 긴 소요 시간을 가지는 경우 나머지 동작들의 실행이 지연될 수 있다.

반대로 ==비동기==는 다른 동작의 실행과 무관하게 기다리지 않고 바로 실행하는 방식이다. 다른 동작의 완료를 기다리지 않기 때문에 소요시간이 짧은 작업은 바로 결과를 볼 수 있다. 다만 앞쪽 코드에서 호출한 함수가 있더라도 뒷쪽 함수에서 그 결과를 받아볼 수 있으리란 보장이 없기 때문에 [[callback]] 등의 방식으로 연결시켜주어야 한다. 주로 [[promise]]를 활용해 순서를 보장한다.

## 동기 상황
- 일반적인 코드의 진행

## 비동기 상황
- `setTimeout()` 등을 통해 함수 실행을 지연, 반복시키는 경우.
- 파일 스트림을 사용해 파일을 읽거나 쓰는 경우.
- 인터넷을 통한 통신.